module mitice_io
!*===========================================================*
! print major seaice vars to NC files.
! note: only support NETCDF; New NC is generated as new month starts
! note: Output is generated by Rank0.
!*===========================================================*
USE mod_mpi_variables
use mitice_debug
use mitice_ave
use mitice_vars
use mitice_parameters
use mitice_itd
   implicit none
   ! a new output folder specified here
   character(20),public, parameter :: foldername = './si_output/'
   character(lc),public, save  :: prefix, prefix_ave
   logical, save :: firstdump

contains
   subroutine seaice_io_init
       firstdump = .true.
   end subroutine seaice_io_init

   subroutine seaice_io_dump(prefix,ts_dump)
!   *===========================================================*
!    dump frames in NC format; a new file each month 
!   *===========================================================*
     implicit none
     !interface vars
     character(*), intent(in) :: prefix
     integer :: ts_dump
     IF ( SEAICEuseEVP ) THEN
          
       !DOWNLOAD TO HOST
       !$acc update self(seaice_sigma1,seaice_sigma2,seaice_sigma12)

       call mpi_data_1d_output_ice_ts(prefix,'seaice_sigma1', seaice_sigma1, ts=ts_dump)
       call mpi_data_1d_output_ice_ts(prefix,'seaice_sigma2', seaice_sigma2, ts=ts_dump)
       call mpi_data_1d_output_ice_ts(prefix,'seaice_sigma12', seaice_sigma12, ts=ts_dump)
     ENDIF

     !DOWNLOAD TO HOST
     !$acc update self(HEFF,AREA,uIce,vIce,EmPmR,Qnet,Qsw)
     !$acc update self(utau,vtau)

     call mpi_data_1d_output_ice_ts(prefix,'HEFF', HEFF, ts=ts_dump)
     call mpi_data_1d_output_ice_ts(prefix,'AREA', AREA, ts=ts_dump)
     call mpi_data_1d_output_ice_ts(prefix,'UICE', uIce, ts=ts_dump)
     call mpi_data_1d_output_ice_ts(prefix,'VICE', vIce, ts=ts_dump)
     call mpi_data_1d_output_ice_ts(prefix,'EmPmR', EmPmR, ts=ts_dump)
     !call mpi_data_1d_output_ice_ts(prefix,'utau', utau, ts=ts_dump)
     !call mpi_data_1d_output_ice_ts(prefix,'vtau', vtau, ts=ts_dump)
     call mpi_data_1d_output_ice_ts(prefix,'Qnet', Qnet, ts=ts_dump)
     call mpi_data_1d_output_ice_ts(prefix,'Qsw', Qsw, ts=ts_dump)
#ifdef SeaiceDebug
     !!$acc update self(stressDivergenceX,stressDivergenceY)
     !!$acc update self(e11,e22)
!     !$acc update self(uFld(:,75),vFld(:,75))
     !call mpi_data_1d_output_ice_ts(prefix,'stressdivx', stressDivergenceX, ts=ts_dump)
     !call mpi_data_1d_output_ice_ts(prefix,'stressdivy', stressDivergenceY, ts=ts_dump)
     !call mpi_data_1d_output_ice_ts(prefix,'e11', e11, ts=ts_dump)
     !call mpi_data_1d_output_ice_ts(prefix,'e22', e22, ts=ts_dump)
     !call mpi_data_1d_output_ice_ts(prefix,'T', tFld(:,75,1), ts=ts_dump)
     !call mpi_data_1d_output_ice_ts(prefix,'S', tFld(:,75,2), ts=ts_dump)
 !    call mpi_data_1d_output_ice_ts(prefix,'U', uFld(:,75), ts=ts_dump)
 !    call mpi_data_1d_output_ice_ts(prefix,'V', vFld(:,75), ts=ts_dump)
     !call mpi_data_1d_output_ice_ts(prefix,'tmp1', tmp_outvar(:,1), ts=ts_dump)
     !call mpi_data_1d_output_ice_ts(prefix,'tmp2', tmp_outvar(:,2), ts=ts_dump)
#endif

   end subroutine seaice_io_dump

   subroutine seaice_io_tave(prefix,ts_ave)
!   *===========================================================*
!   dump time-averaged vars; a new file each month
!   *===========================================================*
     implicit none
     character(*), intent(in) :: prefix
     integer :: ts_ave

     !DOWNLOAD TO HOST
     !$acc update self(UICEtave,VICEtave,EmPmRtave,QNETtave,QSWtave,HEFFtave,AREAtave)
     !$acc update self(UTAUtave,VTAUtave)

     call mpi_data_1d_output_ice_ts(prefix,'UICEtave', UICEtave, ts=ts_ave)
     call mpi_data_1d_output_ice_ts(prefix,'VICEtave', VICEtave, ts=ts_ave)
     !call mpi_data_1d_output_ice_ts(prefix,'UTAUtave', UTAUtave, ts=ts_ave)
     !call mpi_data_1d_output_ice_ts(prefix,'VTAUtave', VTAUtave, ts=ts_ave)
     call mpi_data_1d_output_ice_ts(prefix,'EmPmRtave', EmPmRtave, ts=ts_ave)
     call mpi_data_1d_output_ice_ts(prefix,'QNETtave', QNETtave, ts=ts_ave)
     call mpi_data_1d_output_ice_ts(prefix,'QSWtave', QSWtave, ts=ts_ave)
     call mpi_data_1d_output_ice_ts(prefix,'HEFFtave', HEFFtave, ts=ts_ave)
     call mpi_data_1d_output_ice_ts(prefix,'AREAtave', AREAtave, ts=ts_ave)

   end subroutine seaice_io_tave

   subroutine seaice_output
!  *==========================================================*
!  | o Do SEAICE output and TimeAve averaging and output.
!  *==========================================================*

      implicit none

      INTEGER i
#ifdef SEAICE_ITD
      INTEGER k
#endif
      LOGICAL ::  dumpnow
      integer, save :: ts_dump,ts_ave


      IF (SEAICEwriteState) THEN     !default is false. set in ice_init.

        !the initial value of firstdump is true: for initial fields output
        if(firstdump) then
          ts_dump = 2    ! because the initial frame ts_dump=1
          ts_ave = 1
          firstdump = .false.
        endif

        !update filename prefix with new month num; start a new dump file
        !NxtDumpFile is updated in csp_init_step
        if (NxtDumpFile) then
            write(prefix, '(A,i4.4,i2.2,i2.2,i2.2,i2.2,i2.2,A1)')   &
                trim(adjustl(foldername))//'dump_',nowyear,nowmon,nowday,  &
                nowhour,nowmin,nowsec, '_'
            write(prefix_ave, '(A,i4.4,i2.2,i2.2,i2.2,i2.2,i2.2,A1)')   &
                trim(adjustl(foldername))//'ave_',nowyear,nowmon,nowday,  &
                nowhour,nowmin,nowsec,'_'
            NxtDumpFile = .FALSE.
            ts_dump = 1
            ts_ave  = 1
        endif

        dumpnow = nowTime.EQ.NxtDumpTime .AND. myIter.LE.nIterMax

        !YY: ts_dump always start from 2, since initial field dumped at seaice init
        if (dumpnow) then
          call seaice_io_dump(prefix,ts_dump=ts_dump)
          ts_dump = ts_dump+1
          !nowTime is nowjulian-startTime, with reference to starttime in subroutine init
          NxtDumpTime = nowTime + int(SEAICE_dumpFreq, 8)   ! put in the end
        endif

!----------------------------------------------------------------
!     Do SEAICE time averaging.
!----------------------------------------------------------------

        IF ( SEAICE_taveFreq.GT.0.0_wp ) THEN
!--     Time-cumulations
          call mitice_ave_cumulate
!       Dump files and restart average computation if needed
          dumpnow = nowTime.EQ.NxtAveTime .AND. myIter.LE.nIterMax
          IF (dumpnow) THEN
!        Normalize by integrated time
            call mitice_ave_normalize(SEAICE_taveFreq )
            call seaice_io_tave(prefix_ave,ts_ave=ts_ave)
            ts_ave = ts_ave + 1
            NxtAveTime = nowTime + int(SEAICE_taveFreq, 8)   ! put in the end
          ENDIF
!        Reset averages to zero
          call mitice_ave_reset
        ENDIF

      ENDIF    !endif for write_state

!YY: TO DO LATER
!--   do SEAICE monitor output : print some statistics about seaice fields
!      CALL SEAICE_MONITOR
   end subroutine seaice_output

#ifdef SEAICE_ITD
   subroutine seaice_itd_pickup

!   *===========================================================*
!   | o called in case pickup file does not contain
!   |   ITD variables but mean ice thickness and concentration
!   |
!   | o choose between two schemes:
!   |
!   |   a) a simple scheme where the mean values are just put
!   |      into the first ITD category and then redustributed
!   |      into the correct category by SEAICE_ITD_REDIST
!   |      -> simpleSchemeFlag = .TRUE.
!   |
!   |   b) a scheme that assumes a log-normal distribution based
!   |      on the mean ice thickness and a standard decviation
!   |      of LND_sigma=0.25
!   |      -> simpleSchemeFlag = .FALSE.
!   |
!   | Torge Martin, Mai 2012, torge@mit.edu
!   *===========================================================*

      implicit none


      INTEGER i, k
      real(wp) ::  dummyTime

!     local variables for picking up ITD from single category pickup file
      INTEGER ::  LND_i
      integer, parameter :: LND_iend = 1000
!     parameters for log-normal distribution (LND)
      real(wp) ::  LND_mu, LND_tmp
      real(wp), parameter :: LND_sigma=0.25_wp
!     bin width of distribution
      real(wp), parameter :: LND_dx = 100.0_wp/LND_iend    !LND_dx=0.1_wp
      real(wp) :: LND_x(LND_iend), LND_pdf(LND_iend)
!     flag for pickup scheme
      LOGICAL simpleSchemeFlag

      simpleSchemeFlag = .TRUE.
      dummyTime = 1.0_wp

!     reset ITD variables to zero for safety
!$acc kernels loop collapse(2)
      DO k = 1, nITD
        DO i=1,nlpb
           AREAITD (i,k)  = 0.0_wp
           HEFFITD (i,k)  = 0.0_wp
           HSNOWITD(i,k)  = 0.0_wp
        ENDDO
      ENDDO
!$acc end kernels
      IF (simpleSchemeFlag) THEN
!--      Put all ice into one bin:
!$acc kernels loop
        DO i=1,nlpb
          AREAITD (i,1) = AREA (i)
          HEFFITD (i,1) = HEFF (i)
          HSNOWITD(i,1) = HSNOW(i)
        ENDDO
!$acc end kernels
      ELSE
!--      Assume log-normal ITD:
!$acc kernels create(LND_x)
!$acc loop gang,vector private(LND_mu,LND_tmp,k)
        DO i=1,nlpb

!         initialize log-normal distribution
          LND_mu = log(HEFF(i)/AREA(i)) - 0.5*LND_sigma*LND_sigma
          LND_x(1) = 0.0_wp+LND_dx/2.0_wp
!         make thickness bins
!$acc loop seq
          DO LND_i=2,LND_iend
            LND_x(LND_i)=LND_x(LND_i-1)+LND_dx
          ENDDO
!         log-normal distribution:
!$acc loop seq
          DO LND_i=2,LND_iend
            LND_tmp = log(LND_x(LND_i))-LND_mu
            LND_pdf(LND_i)= 1.0_wp / (LND_x(LND_i)*LND_sigma*sqrt(2.0*3.1416))    &
               * exp( -(LND_tmp*LND_tmp) / (2*LND_sigma*LND_sigma) ) * AREA(i)
          ENDDO
!         assign bins to ice thickness categories
          k=1
!$acc loop seq
          DO LND_i=1,LND_iend
            IF ( LND_x(LND_i).GT.Hlimit(k) ) k=k+1
            AREAITD(i,k) = AREAITD(i,k) + LND_pdf(LND_i)*LND_dx
            HEFFITD(i,k) = HEFFITD(i,k) + LND_pdf(LND_i)*LND_x(LND_i)*LND_dx
          ENDDO
        ENDDO
!$acc end kernels
      ENDIF

!     finally sort into correct ice thickness category and compute bulk variables
!      (needed for dynamic solver at beginning of seaice_model.F)
      call seaice_itd_redist
      call seaice_itd_sum

   end subroutine seaice_itd_pickup
#endif /* SEAICE_ITD */

end module mitice_io
