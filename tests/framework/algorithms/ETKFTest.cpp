/**
 * @file ETKFTest.cpp
 * @brief Unit tests for the Ensemble Transform Kalman Filter (ETKF)
 * implementation
 */

#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <cmath>
#include <numbers>
#include <random>

#include "Config.hpp"
#include "ETKF.hpp"
#include "Ensemble.hpp"
#include "Geometry.hpp"
#include "Metrics.hpp"
#include "MockBackendTraits.hpp"
#include "ObsOperator.hpp"
#include "Observation.hpp"

using ::testing::Invoke;
using ::testing::Return;
using ::testing::ReturnRef;

namespace metada::tests {

/**
 * @brief Test fixture for ETKF tests
 *
 * Sets up mock data and components needed for testing the ETKF implementation:
 * - Mock ensemble data (10 elements, each with 3 state variables)
 * - Mock observation data (3 elements)
 * - Mock observation error covariance matrix (3x3 diagonal matrix)
 * - Configuration loaded from test_config.yaml
 * - Geometry instance initialized from config
 * - Ensemble instance with mock backend
 * - Observation instance with mock backend
 * - Observation operator instance with mock backend
 * - ETKF instance with 1.1 inflation factor
 *
 * The ensemble members are generated by adding Gaussian perturbations (mean=0,
 * std=0.1) to a base state of [1.0, 2.0, 3.0].
 *
 * The observations are generated similarly but with smaller Gaussian errors
 * (std=0.05). The observation error covariance is a diagonal matrix with
 * variance 0.01.
 */
class ETKFTest : public ::testing::Test {
 protected:
  void SetUp() override {
    // Setup mock data
    ens_size_ = 50;
    state_dim_ = 1000;

    // True state around which to perturb
    true_state_.resize(state_dim_);
    for (size_t i = 0; i < state_dim_; ++i) {
      double angle = i * 360.0 / state_dim_;  // Convert to degrees
      true_state_[i] = std::cos(angle * std::numbers::pi / 180.0);
    }

    // Create random number generator for Gaussian perturbations
    std::random_device rd;
    std::mt19937 gen(rd());
    std::normal_distribution<double> dist(0.2, 0.1);  // mean=0.2, std=0.1

    // Generate ensemble members by adding Gaussian perturbations to base state
    ensemble_data_.resize(ens_size_);
    for (size_t i = 0; i < ens_size_; ++i) {
      ensemble_data_[i].resize(state_dim_);
      for (size_t j = 0; j < state_dim_; ++j) {
        ensemble_data_[i][j] = true_state_[j] + dist(gen);
      }
    }

    // Create observation data with Gaussian errors
    // Using a different random number generator for observations
    std::mt19937 obs_gen(rd());
    std::normal_distribution<double> obs_dist(
        0.0, 0.05);  // smaller std for observations

    // Generate observations by adding smaller Gaussian errors to base state
    obs_data_.resize(state_dim_);
    for (size_t i = 0; i < state_dim_; ++i) {
      obs_data_[i] = true_state_[i] + obs_dist(obs_gen);
    }

    // Create observation error covariance matrix (state_dim_ x state_dim_)
    // Using diagonal matrix with small variances
    cov_data_ = std::vector<double>(state_dim_ * state_dim_, 0.0);
    for (size_t i = 0; i < state_dim_; ++i) {
      cov_data_[i * state_dim_ + i] =
          0.01;  // Set diagonal elements to variance 0.01
    }  // state_dim_ x state_dim_ diagonal matrix with variance 0.01

    // Load configuration file from test directory
    auto test_dir = std::filesystem::path(__FILE__).parent_path();
    config_file_ = (test_dir / "test_config.yaml").string();

    // Create config and geometry
    config_ = std::make_unique<framework::Config<traits::MockBackendTag>>(
        config_file_);
    geometry_ =
        std::make_unique<framework::Geometry<traits::MockBackendTag>>(*config_);

    // Setup mock expectations for config
    ON_CALL(config_->backend(), Get("ensemble.size"))
        .WillByDefault(
            Return(framework::ConfigValue(static_cast<int>(ens_size_))));

    // Create adapter instances
    ensemble_ = std::make_unique<framework::Ensemble<traits::MockBackendTag>>(
        *config_, *geometry_);
    obs_ = std::make_unique<framework::Observation<traits::MockBackendTag>>(
        *config_);
    obs_op_ = std::make_unique<framework::ObsOperator<traits::MockBackendTag>>(
        *config_);

    // Setup mock expectations for ensemble member data
    for (size_t i = 0; i < ens_size_; ++i) {
      ensemble_->GetMember(i).backend().setData(ensemble_data_[i]);
    }

    // setup mock expectations for observation data
    obs_->backend().setData(obs_data_);
    obs_->backend().setCovariance(cov_data_);

    // Create LETKF instance
    etkf_ = std::make_unique<framework::ETKF<traits::MockBackendTag>>(
        *ensemble_, *obs_, *obs_op_, 1.1);
  }

  void TearDown() override {
    // Reset all unique pointers
    etkf_.reset();
    obs_op_.reset();
    obs_.reset();
    ensemble_.reset();
    geometry_.reset();
    config_.reset();

    // Clear data vectors
    ensemble_data_.clear();
    obs_data_.clear();
    cov_data_.clear();
    true_state_.clear();
  }

  size_t ens_size_;
  size_t state_dim_;
  std::vector<std::vector<double>> ensemble_data_;
  std::vector<double> obs_data_;
  std::vector<double> cov_data_;
  std::vector<double> true_state_;
  std::string config_file_;
  std::unique_ptr<framework::Config<traits::MockBackendTag>> config_;
  std::unique_ptr<framework::Geometry<traits::MockBackendTag>> geometry_;
  std::unique_ptr<framework::Ensemble<traits::MockBackendTag>> ensemble_;
  std::unique_ptr<framework::Observation<traits::MockBackendTag>> obs_;
  std::unique_ptr<framework::ObsOperator<traits::MockBackendTag>> obs_op_;
  std::unique_ptr<framework::ETKF<traits::MockBackendTag>> etkf_;
};

/**
 * @brief Test that LETKF constructor properly initializes the instance
 *
 * Verifies that the LETKF instance is created successfully with all required
 * components and the pointer is not null.
 */
TEST_F(ETKFTest, ConstructorInitializesCorrectly) {
  EXPECT_NE(etkf_, nullptr);
}

/**
 * @brief Test the LETKF analysis step
 *
 * Verifies that:
 * - The observation operator is called exactly 10 times (once per ensemble
 * member)
 * - The analysis step completes without errors
 * - The observation operator correctly maps ensemble states to observation
 * space
 *
 * The test sets up mock behavior for the observation operator to return
 * ensemble data as simulated observations.
 */
TEST_F(ETKFTest, AnalysisUpdatesEnsemble) {
  // Setup expectations for the analysis step
  EXPECT_CALL(obs_op_->backend(), apply(::testing::_, ::testing::_))
      .Times(ens_size_)
      .WillRepeatedly(
          ::testing::Invoke([this]([[maybe_unused]] const auto& state,
                                   [[maybe_unused]] const auto& obs_) {
            static size_t call_count = 0;
            return ensemble_data_[call_count++];
          }));

  // Calculate initial metrics
  auto initial_metrics = framework::Metrics<>::CalculateAll(
      ensemble_data_, true_state_, state_dim_, ens_size_);

  std::cout << "Initial Metrics:" << std::endl;
  std::cout << initial_metrics;

  // Perform analysis
  etkf_->Analyse();

  // Get updated ensemble data
  std::vector<std::vector<double>> updated_ensemble_data(ens_size_);
  for (size_t i = 0; i < ens_size_; ++i) {
    updated_ensemble_data[i] =
        ensemble_->GetMember(i).template getData<std::vector<double>>();
  }

  // Calculate final metrics
  auto final_metrics = framework::Metrics<>::CalculateAll(
      updated_ensemble_data, true_state_, state_dim_, ens_size_);

  std::cout << "\nFinal Metrics:" << std::endl;
  std::cout << final_metrics;

  // Add assertions to verify improvement
  EXPECT_LT(final_metrics.rmse, initial_metrics.rmse);
  // EXPECT_GT(final_metrics.correlation, initial_metrics.correlation);
  // EXPECT_LT(final_metrics.crps, initial_metrics.crps);
  EXPECT_LT(final_metrics.bias, initial_metrics.bias);
  EXPECT_LT(final_metrics.avg_spread, initial_metrics.avg_spread);
}

}  // namespace metada::tests