/**
 * @file LETKFTest.cpp
 * @brief Unit tests for the Local Ensemble Transform Kalman Filter (LETKF)
 * implementation
 */

#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <cmath>
#include <numbers>
#include <random>

#include "Config.hpp"
#include "Ensemble.hpp"
#include "Geometry.hpp"
#include "LETKF.hpp"
#include "Metrics.hpp"
#include "MockBackendTraits.hpp"
#include "ObsOperator.hpp"
#include "Observation.hpp"

using ::testing::Invoke;
using ::testing::Return;
using ::testing::ReturnRef;

namespace metada::tests {

/**
 * @brief Test fixture for LETKF tests
 *
 * Sets up mock data and components needed for testing the LETKF implementation:
 * - Mock ensemble data (10 elements, each with 3 state variables)
 * - Mock observation data (3 elements)
 * - Mock observation error covariance matrix (3x3 diagonal matrix)
 * - Configuration loaded from test_config.yaml
 * - Geometry instance initialized from config
 * - Ensemble instance with mock backend
 * - Observation instance with mock backend
 * - Observation operator instance with mock backend
 * - LETKF instance with 1.1 inflation factor
 *
 * The ensemble members are generated by adding Gaussian perturbations (mean=0,
 * std=0.1) to a base state of [1.0, 2.0, 3.0].
 *
 * The observations are generated similarly but with smaller Gaussian errors
 * (std=0.05). The observation error covariance is a diagonal matrix with
 * variance 0.01.
 */
class LETKFTest : public ::testing::Test {
 protected:
  void SetUp() override {
    // Setup mock data
    ens_size_ = 50;
    state_dim_ = 1000;

    // True state around which to perturb
    true_state_.resize(state_dim_);
    for (size_t i = 0; i < state_dim_; ++i) {
      double angle = i * 360.0 / state_dim_;  // Convert to degrees
      true_state_[i] = std::cos(angle * std::numbers::pi / 180.0);
    }

    // Create random number generator for Gaussian perturbations
    std::random_device rd;
    std::mt19937 gen(rd());
    std::normal_distribution<double> dist(0.0, 0.1);  // mean=0, std=0.1

    // Generate ensemble members by adding Gaussian perturbations to base state
    ensemble_data_.resize(ens_size_);
    for (size_t i = 0; i < ens_size_; ++i) {
      ensemble_data_[i].resize(state_dim_);
      for (size_t j = 0; j < state_dim_; ++j) {
        ensemble_data_[i][j] = true_state_[j] + dist(gen);
      }
    }

    // Create observation data with Gaussian errors
    // Using a different random number generator for observations
    std::mt19937 obs_gen(rd());
    std::normal_distribution<double> obs_dist(
        0.0, 0.05);  // smaller std for observations

    // Generate observations by adding smaller Gaussian errors to base state
    obs_data_.resize(state_dim_);
    for (size_t i = 0; i < state_dim_; ++i) {
      obs_data_[i] = true_state_[i] + obs_dist(obs_gen);
    }

    // Create observation error covariance matrix (state_dim_ x state_dim_)
    // Using diagonal matrix with small variances
    cov_data_ = std::vector<double>(state_dim_ * state_dim_, 0.0);
    for (size_t i = 0; i < state_dim_; ++i) {
      cov_data_[i * state_dim_ + i] =
          0.01;  // Set diagonal elements to variance 0.01
    }  // state_dim_ x state_dim_ diagonal matrix with variance 0.01

    // Load configuration file from test directory
    auto test_dir = std::filesystem::path(__FILE__).parent_path();
    config_file_ = (test_dir / "test_config.yaml").string();

    // Create config and geometry
    config_ = std::make_unique<framework::Config<traits::MockBackendTag>>(
        config_file_);
    geometry_ =
        std::make_unique<framework::Geometry<traits::MockBackendTag>>(*config_);

    // Setup mock expectations for config
    ON_CALL(config_->backend(), Get("ensemble.size"))
        .WillByDefault(
            Return(framework::ConfigValue(static_cast<int>(ens_size_))));

    // Create adapter instances
    ensemble_ = std::make_unique<framework::Ensemble<traits::MockBackendTag>>(
        *config_, *geometry_);
    obs_ = std::make_unique<framework::Observation<traits::MockBackendTag>>(
        *config_);
    obs_op_ = std::make_unique<framework::ObsOperator<traits::MockBackendTag>>(
        *config_);

    // Setup mock expectations for ensemble member data
    for (size_t i = 0; i < ens_size_; ++i) {
      ensemble_->GetMember(i).backend().setData(ensemble_data_[i]);
    }

    // setup mock expectations for observation data
    obs_->backend().setData(obs_data_);
    obs_->backend().setCovariance(cov_data_);

    // Create LETKF instance
    letkf_ = std::make_unique<framework::LETKF<traits::MockBackendTag>>(
        *ensemble_, *obs_, *obs_op_, 1.1);
  }

  void TearDown() override {
    // Reset all unique pointers
    letkf_.reset();
    obs_op_.reset();
    obs_.reset();
    ensemble_.reset();
    geometry_.reset();
    config_.reset();

    // Clear data vectors
    ensemble_data_.clear();
    obs_data_.clear();
    cov_data_.clear();
    true_state_.clear();
  }

  /**
   * @brief Calculate ensemble mean
   * @param ensemble_data Vector of ensemble member data
   * @return Vector containing the mean at each point
   */
  std::vector<double> calculateEnsembleMean(
      const std::vector<std::vector<double>>& ensemble_data) {
    std::vector<double> mean(state_dim_, 0.0);
    for (const auto& member : ensemble_data) {
      for (size_t i = 0; i < state_dim_; ++i) {
        mean[i] += member[i];
      }
    }
    for (auto& val : mean) {
      val /= ens_size_;
    }
    return mean;
  }

  /**
   * @brief Calculate ensemble spread (standard deviation)
   * @param ensemble_data Vector of ensemble member data
   * @param mean Ensemble mean
   * @return Vector containing the spread at each point
   */
  std::vector<double> calculateEnsembleSpread(
      const std::vector<std::vector<double>>& ensemble_data,
      const std::vector<double>& mean) {
    std::vector<double> spread(state_dim_, 0.0);
    for (const auto& member : ensemble_data) {
      for (size_t i = 0; i < state_dim_; ++i) {
        double diff = member[i] - mean[i];
        spread[i] += diff * diff;
      }
    }
    for (auto& val : spread) {
      val = std::sqrt(val / (ens_size_ - 1));
    }
    return spread;
  }

  /**
   * @brief Calculate bias
   * @param mean Ensemble mean
   * @param truth True state
   * @return Average bias
   */
  double calculateBias(const std::vector<double>& mean,
                       const std::vector<double>& truth) {
    double bias = 0.0;
    for (size_t i = 0; i < state_dim_; ++i) {
      bias += mean[i] - truth[i];
    }
    return bias / state_dim_;
  }

  /**
   * @brief Calculate correlation coefficient
   * @param mean Ensemble mean
   * @param truth True state
   * @return Correlation coefficient
   */
  double calculateCorrelation(const std::vector<double>& mean,
                              const std::vector<double>& truth) {
    double sum_x = 0.0, sum_y = 0.0, sum_xy = 0.0;
    double sum_x2 = 0.0, sum_y2 = 0.0;

    for (size_t i = 0; i < state_dim_; ++i) {
      sum_x += mean[i];
      sum_y += truth[i];
      sum_xy += mean[i] * truth[i];
      sum_x2 += mean[i] * mean[i];
      sum_y2 += truth[i] * truth[i];
    }

    double n = static_cast<double>(state_dim_);
    double numerator = n * sum_xy - sum_x * sum_y;
    double denominator =
        std::sqrt((n * sum_x2 - sum_x * sum_x) * (n * sum_y2 - sum_y * sum_y));

    return numerator / denominator;
  }

  /**
   * @brief Calculate Continuous Ranked Probability Score (CRPS)
   * @param ensemble_data Vector of ensemble member data
   * @param truth True state
   * @return CRPS value
   */
  double calculateCRPS(const std::vector<std::vector<double>>& ensemble_data,
                       const std::vector<double>& truth) {
    double crps = 0.0;
    for (size_t i = 0; i < state_dim_; ++i) {
      double sum_diff = 0.0;
      for (size_t j = 0; j < ens_size_; ++j) {
        for (size_t k = 0; k < ens_size_; ++k) {
          sum_diff += std::abs(ensemble_data[j][i] - ensemble_data[k][i]);
        }
      }
      double sum_truth_diff = 0.0;
      for (size_t j = 0; j < ens_size_; ++j) {
        sum_truth_diff += std::abs(ensemble_data[j][i] - truth[i]);
      }
      crps +=
          sum_truth_diff / ens_size_ - sum_diff / (2.0 * ens_size_ * ens_size_);
    }
    return crps / state_dim_;
  }

  size_t ens_size_;
  size_t state_dim_;
  std::vector<std::vector<double>> ensemble_data_;
  std::vector<double> obs_data_;
  std::vector<double> cov_data_;
  std::vector<double> true_state_;
  std::string config_file_;
  std::unique_ptr<framework::Config<traits::MockBackendTag>> config_;
  std::unique_ptr<framework::Geometry<traits::MockBackendTag>> geometry_;
  std::unique_ptr<framework::Ensemble<traits::MockBackendTag>> ensemble_;
  std::unique_ptr<framework::Observation<traits::MockBackendTag>> obs_;
  std::unique_ptr<framework::ObsOperator<traits::MockBackendTag>> obs_op_;
  std::unique_ptr<framework::LETKF<traits::MockBackendTag>> letkf_;
};

/**
 * @brief Test that LETKF constructor properly initializes the instance
 *
 * Verifies that the LETKF instance is created successfully with all required
 * components and the pointer is not null.
 */
TEST_F(LETKFTest, ConstructorInitializesCorrectly) {
  EXPECT_NE(letkf_, nullptr);
}

/**
 * @brief Test the LETKF analysis step
 *
 * Verifies that:
 * - The observation operator is called exactly 10 times (once per ensemble
 * member)
 * - The analysis step completes without errors
 * - The observation operator correctly maps ensemble states to observation
 * space
 *
 * The test sets up mock behavior for the observation operator to return
 * ensemble data as simulated observations.
 */
TEST_F(LETKFTest, AnalysisUpdatesEnsemble) {
  // Setup expectations for the analysis step
  EXPECT_CALL(obs_op_->backend(), apply(::testing::_, ::testing::_))
      .Times(ens_size_)
      .WillRepeatedly(
          ::testing::Invoke([this]([[maybe_unused]] const auto& state,
                                   [[maybe_unused]] const auto& obs_) {
            static size_t call_count = 0;
            return ensemble_data_[call_count++];
          }));

  // Calculate initial metrics
  auto initial_metrics = framework::Metrics<>::CalculateAll(
      ensemble_data_, true_state_, state_dim_, ens_size_);

  std::cout << "Initial Metrics:" << std::endl;
  std::cout << initial_metrics;

  // Perform analysis
  letkf_->Analyse();

  // Get updated ensemble data
  std::vector<std::vector<double>> updated_ensemble_data(ens_size_);
  for (size_t i = 0; i < ens_size_; ++i) {
    updated_ensemble_data[i] =
        ensemble_->GetMember(i).template getData<std::vector<double>>();
  }

  // Calculate final metrics
  auto final_metrics = framework::Metrics<>::CalculateAll(
      updated_ensemble_data, true_state_, state_dim_, ens_size_);

  std::cout << "\nFinal Metrics:" << std::endl;
  std::cout << final_metrics;

  // Add assertions to verify improvement
  EXPECT_LT(final_metrics.rmse, initial_metrics.rmse);
  EXPECT_GT(final_metrics.correlation, initial_metrics.correlation);
  EXPECT_LT(final_metrics.crps, initial_metrics.crps);
  EXPECT_NEAR(final_metrics.bias, 0.0, 0.1);  // Bias should be close to zero
  EXPECT_NEAR(final_metrics.avg_spread, final_metrics.rmse,
              0.1);  // Spread should match RMSE
}

}  // namespace metada::tests